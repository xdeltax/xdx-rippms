import debuglog from "../debug/consolelog.mjs"; const clog = debuglog(import.meta.url);

import fse from 'fs-extra';
import path from 'path';
import crypto from 'crypto';
import Joi from '@hapi/joi';

import DBPrototype from "./DBPrototype.mjs";
import Datastore from 'nedb-promises';
import {mongoConnect, mongoCollection} from './adapter/mongodb.mjs';

import {abs_path, } from "../basepath.mjs";
import {unixtime,} from "../tools/datetime.mjs";
import {isERROR, isSUCCESS, } from "../tools/isErrorIsSuccess.mjs";
import joiValidateFallback from '../tools/joiValidateFallback.mjs';

import {joi_databaseid, joi_userid, joi_servertoken,
        joi_createdAt, joi_updatedAt,
        joi_mapid,
        joi_number, joi_binary,
        joi_name, joi_email, joi_phonenumber,
       } from "./joiValidators.mjs";

import * as arrayBufferTilemap from '../tools/arrayBufferTilemap.mjs';


const joi_schemaObject = Joi.object().keys({
  // autogenerated properties
  _id: 					joi_databaseid.optional(), // UNIQUE
  // public properties - fixed
  groundlayerid:joi_number.optional(), // UNIQUE: number 1 to x

  linenumber:   joi_number.optional(),
  linedata:     joi_binary,

  // auto-updated properties
  createdAt: 		joi_createdAt,
  updatedAt: 		joi_updatedAt,
});


export default class DBGameGroundLayers extends DBPrototype {
  constructor(name) {
    super(name || "gamegroundlayers");
  }

  connect = async () => { // static method (not affected by instance) -> called with classname: DBGeoData.load
    const count = await super.connect();

    await super.createIndex("groundlayerid", false);

    return count;
  }; // of connect



	get = async (groundlayerid, linenumber) => {
    try {
			const valid_groundlayerid= joiValidateFallback(groundlayerid, null, joi_number);
			const valid_linenumber   = joiValidateFallback(linenumber   , null, joi_number);
			if (isNaN(valid_groundlayerid) || isNaN(valid_linenumber)) throw isERROR(1, "DBGameGroundLayers: get", "query failed", "invalid id or line");

      const thisObject = await this.findOne({ "groundlayerid": valid_groundlayerid },); // not found -> null

	  	return isSUCCESS(thisObject);
	  } catch (error) {
	  	return isERROR(99, "DBUsercards: getUsercard", "usercard query failed", error);
	  }
	}

  set = async (groundlayerid, width, height) => {
    try {
			const valid_groundlayerid= joiValidateFallback(groundlayerid, null, joi_number);
			if (isNaN(valid_groundlayerid)) throw isERROR(1, "DBGameGroundLayers: set", "query failed", "invalid id or line");

      const bufferBytes = 1;
      for (let tileY = 0; tileY < height; tileY++) {
        clog("+++1", groundlayerid, width, height, tileY)
        //map.data2D[tileY] = new Array(map.tilemapConfig.width);
        const arrBuf = arrayBufferTilemap.createArrayBuffer(bufferBytes, width, 1); // new ArrayBuffer(bufferBytes * width * height);
        const dataView = arrayBufferTilemap.createDataView(arrBuf);

        for (let tileX = 0; tileX < width; tileX++) {
          const obj = {
            assetID: 0,
            frameID: 0,
          }
          switch (Math.floor(9 * Math.random())) {
            case 0: obj.frameID = Math.floor(30 * Math.random()); break; // animation state of boy (0 .. 30)
            case 1: obj.frameID = 31; break; // boy, not animatable
            default:obj.frameID = 32; break; // empty block
          };


          dataView[tileX] = arrayBufferTilemap.groundlayer_objectToUint8(obj);
        }

        const dataobj = {
          groundlayerid: valid_groundlayerid,
          linenumber: tileY,
          dataViewString: String.fromCharCode.apply(null, new Uint8Array(arrBuf)),
        }

        clog("+++2", groundlayerid, width, height, arrBuf.toString());
        const numReplace = await super.updateFull({ groundlayerid: valid_groundlayerid, linenumber: tileY }, dataobj);
      }

	  	return true;
	  } catch (error) {
	  	return isERROR(99, "DBUsercards: getUsercard", "usercard query failed", error);
	  }
	}


  ab2str = (buf) => {
    return String.fromCharCode.apply(null, new Uint16Array(buf));
  }

  str2ab(str) {
    var buf = new ArrayBuffer(str.length*2); // 2 bytes for each char
    var bufView = new Uint16Array(buf);
    for (var i=0, strLen=str.length; i < strLen; i++) {
      bufView[i] = str.charCodeAt(i);
    }
    return buf;
  }
}
