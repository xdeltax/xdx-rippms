import debuglog from "../debug/consolelog.mjs"; const clog = debuglog(import.meta.url);

import fse from 'fs-extra';
import path from 'path';
import crypto from 'crypto';
import Joi from '@hapi/joi';

import DBPrototype from "./DBPrototype.mjs";
import Datastore from 'nedb-promises';
import {mongoConnect, mongoCollection} from './adapter/mongodb.mjs';

import {abs_path, } from "../basepath.mjs";
import {unixtime,} from "../tools/datetime.mjs";
import {isERROR, isSUCCESS, } from "../tools/isErrorIsSuccess.mjs";
import joiValidateFallback from '../tools/joiValidateFallback.mjs';

import {joi_databaseid, joi_userid,
        joi_socketid, joi_count, joi_date,
       } from './joiValidators.mjs';


const joi_schemaObject = Joi.object().keys({
  _id: 					joi_databaseid.optional(),

  socketid: 		joi_socketid.required(),
  userid: 			joi_userid.allow(null).optional(),

  //apicalls
  count: 				joi_count,
  countSince: 	joi_date,

  createdAt: 		joi_date,
  updatedAt: 		joi_date,
});


export default class DBSockets extends DBPrototype {
  constructor(name) {
    super(name || "sockets");
  }

  _getINTERNAL = async (valid_socketid, isOWN) => {
    const dbResultLimited = (item) => { // keep or drop props
      // const dbGallery = array.map(( {propsToDrop1, propsToDrop2, ...keepAttrs}) => keepAttrs)
      // const dbGallery = array.map(( {propsToKeep1, propsToKeep2, } ) => ( {propsToKeep1, propsToKeep2, } ))
      // filter item
      let { // get from object
      	socketid,
        userid,
        count,
        countSince,
        updatedAt,
        createdAt,
      } = item;
      // modify object
      //fname = (viewgroup==="all") ? fname : fblur;
      return { // set to new object
      	socketid,
        userid,
        count,
        countSince,
        updatedAt,
        createdAt,
      }
    };
    try {
      const dbResultFull = await super.findOne({ "socketid": valid_socketid, },); // not found -> null
      // if isOwn -> return full database entry; if !isOwn -> return limited dataset only
      if (dbResultFull && dbResultFull.hasOwnProperty("socketid"))
      return (isOWN) ? dbResultFull : dbResultLimited(dbResultFull);
    } catch (error) { // fail silent
      //clog("DBSockets:: _getINTERNAL:: ERROR:: ", error)
      return null;
    }
  }


	remove = async (unsafe_socketid) => { // create or update database
    const now = unixtime();
		try {
		  // ===============================================
		  // normalize input
		  // ===============================================
	    const safe_socketid = joiValidateFallback(unsafe_socketid, null, joi_socketid);
			if (!safe_socketid) throw isERROR(1, "DBSockets: remove", "remove socket failed", "invalid socket id");

	    const numRemoved = await super.deleteOne({ socketid: safe_socketid });
			//if (!numRemoved !== 1) throw ERROR(2, "remove socket failed", "invalid count: " + numRemoved);

	  	return isSUCCESS(numRemoved);
	  } catch (error) {
	  	return isERROR(99, "DBSockets: remove", "remove socket failed", error);
	  }
	};


	createOrUpdate = async (unsafe_socketid, unsafe_userid, ) => { // create or update database
    const now = unixtime();
		try {
		  // ===============================================
		  // normalize input
		  // ===============================================
	    const valid_socketid = joiValidateFallback(unsafe_socketid, null, joi_socketid);
			if (!valid_socketid) throw isERROR(1, "DBSockets: createOrUpdate", "update socket failed", "invalid socket id");

			const valid_userid = joiValidateFallback(unsafe_userid, null, joi_userid, /*options*/null, /*dontLogError*/true);

		  // ===============================================
		  // search db
		  // ===============================================
	    // check if user already exists (and get user data for login-count then)
	    //let thisUser = await super.findOne( { "userid": userid_created, }, ); // not found -> null
      let thisObject = await this._getINTERNAL(valid_socketid, /*isOwn:*/ true); // result will be different (reduced) for isOWN = false

	    const isNewObject = Boolean(!thisObject);

		  // ===============================================
		  // create user-object (if socket.id not in db)
		  // ===============================================
	    // create new user-account in server-database if user not found
	    if (isNewObject || !thisObject.hasOwnProperty("socketid")) {
	      thisObject = {
	        //_id: (unique hash) generated by database
	        socketid: valid_socketid,
	        //userid: safe_userid,

	        count: 0,
	        countSince: now,

	        createdAt: now,
	        //updatedAt: Date.now() / 1000,
	      };
	    }

		  // ===============================================
	    // update userdata with new servertoken
		  // ===============================================
	    thisObject.userid = valid_userid;
	    thisObject.updatedAt = now;

		  // ===============================================
	    // check userdata
		  // ===============================================
	    const valid_object = joiValidateFallback(thisObject, null, joi_schemaObject);
	    //clog("DBSockets:: createOrUpdate:: object:: ", valid_object.userid)
	    if (!valid_object) throw isERROR(2, "DBSockets: createOrUpdate", "update socket failed", "invalid schema");

		  // ===============================================
	    // update user in database
		  // ===============================================
	    const numReplace = await super.updateFull( {socketid: valid_object.socketid}, valid_object);
	    //if (numReplace !== 1) throw isERROR(3, "DBSockets: createOrUpdate", "update socket failed", "invalid update count");

		  // ===============================================
	    // get user from database (own -> true)
		  // ===============================================
      const loadedObject = await this._getINTERNAL(valid_object.socketid, /*isOwn:*/ true); // result will be different (reduced) for isOWN = false

	  	return isSUCCESS(loadedObject);
	  } catch (error) {
	  	//clog("DBSockets:: ERROR:: ", unsafe_socketid, error)
	  	return isERROR(99, "DBSockets: createOrUpdate", "update socket failed", error);
	  }
	}


	updateCount = async (unsafe_socketid) => {
    const now = unixtime();
		try {
		  // ===============================================
		  // normalize input
		  // ===============================================
	    const valid_socketid = joiValidateFallback(unsafe_socketid, null, joi_socketid);
			if (!valid_socketid) throw isERROR(1, "DBSockets: updateCount", "update api-count failed", "invalid socket id");

		  // ===============================================
		  // search db
		  // ===============================================
      let thisObject = await this._getINTERNAL(valid_socketid, /*isOwn:*/ true); // result will be different (reduced) for isOWN = false
	    if (!thisObject) throw isERROR(2, "DBSockets: updateCount", "update api-count failed", "socket id not found");

      thisObject.count++;

	    const numReplace = await super.updateFull( {socketid: thisObject.socketid}, thisObject);
	    if (numReplace !== 1) throw isERROR(3, "DBSockets: updateCount", "update api-count failed", "invalid update count");

	  	return isSUCCESS(thisObject.count);
	  } catch (error) {
	  	return isERROR(99, "DBSockets: updateCount", "update api-count failed", error);
	  }
	}

}
